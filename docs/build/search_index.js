var documenterSearchIndex = {"docs":
[{"location":"man/gen/#gen.jl-Documentation-1","page":"Gen","title":"gen.jl Documentation","text":"","category":"section"},{"location":"man/gen/#","page":"Gen","title":"Gen","text":"CurrentModule = gen","category":"page"},{"location":"man/gen/#gen.ProblemGeneratorSimple-1","page":"Gen","title":"gen.ProblemGeneratorSimple","text":"","category":"section"},{"location":"man/gen/#","page":"Gen","title":"Gen","text":"ProblemGeneratorSimple(util,shock,cap,shock_distribution,mode)","category":"page"},{"location":"man/gen/#gen.ProblemGeneratorSimple-NTuple{5,Any}","page":"Gen","title":"gen.ProblemGeneratorSimple","text":"ProblemGeneratorSimple(util,shock,cap,shock_distribution,mode)\n\nTakes input parameters for base utilities, quantiles at which preferences are obtained, capacities of objects, and distribution (given as Distributions.jl type).\n\n\n\n\n\n","category":"method"},{"location":"man/gen/#","page":"Gen","title":"Gen","text":"Takes DataFrame inputs for utilities, shocks, capacities, and takes distributions for the shocks over each mean. Supports either a single distribution type for all inputs (e.g. Logistic()) or an array of distributions types of size equal to the number of means (e.g. [Logistic(),Logistic(),Logistic()] ). Can be switched into DataFrame mode (mode=\"DF\") and CSV mode (mode=\"CSV\"), depending on input type.","category":"page"},{"location":"man/gen/#","page":"Gen","title":"Gen","text":"Returns an array of types (where entry (i,j) represents the value type i assigns to object j), an array of probabilities over these types (the distribution), and the capacity array.","category":"page"},{"location":"man/gen/#","page":"Gen","title":"Gen","text":"note: Note\nshock_distribution currently supports only continuous distributions included in Distributions.jl. For example, Logistic() is a valid input, but logistic is not. Please see this link for more details.","category":"page"},{"location":"man/gen/#","page":"Gen","title":"Gen","text":"Let us consider an example where the problem specification is given as a set of DataFrames through the command line:","category":"page"},{"location":"man/gen/#","page":"Gen","title":"Gen","text":"using DataFrames, Distributions\ninclude(abspath(\"../../../../basic-program-share/src/solver/modules/gen/src/gen.jl\"))\ncap_df = DataFrame(cap =[.7,.3]); util_df = DataFrame(mean =[15,20]); shock_df = DataFrame(shock=[.1,.8])\ngen.ProblemGeneratorSimple(util_df,shock_df,cap_df,Logistic(),\"DF\")[1]\ngen.ProblemGeneratorSimple(util_df,shock_df,cap_df,Logistic(),\"DF\")[2]\ngen.ProblemGeneratorSimple(util_df,shock_df,cap_df,Logistic(),\"DF\")[3]","category":"page"},{"location":"man/gen/#","page":"Gen","title":"Gen","text":"Now, let us consider an example where the problem specification is given as a set of paths to the appropriate CSV files:","category":"page"},{"location":"man/gen/#","page":"Gen","title":"Gen","text":"using DataFrames, CSV, Distributions\ninclude(abspath(\"../../../../basic-program-share/src/solver/modules/gen/src/gen.jl\"))\ncap_df = DataFrame(cap =[.7,.3]); util_df = DataFrame(mean =[15,20]); shock_df = DataFrame(shock=[.1,.8])\nCSV.write(\"cap.csv\", cap_df, writeheader=true);CSV.write(\"util.csv\", util_df, writeheader=true);CSV.write(\"shock.csv\", shock_df, writeheader=true)\ngen.ProblemGeneratorSimple(\"util.csv\",\"shock.csv\",\"cap.csv\",[Logistic(),Uniform()],\"CSV\")[1]\ngen.ProblemGeneratorSimple(\"util.csv\",\"shock.csv\",\"cap.csv\",[Logistic(),Uniform()],\"CSV\")[2]\ngen.ProblemGeneratorSimple(\"util.csv\",\"shock.csv\",\"cap.csv\",[Logistic(),Uniform()],\"CSV\")[3]\nrm(\"util.csv\");rm(\"shock.csv\");rm(\"cap.csv\")","category":"page"},{"location":"man/gen/#","page":"Gen","title":"Gen","text":"We recommend this second method for ease of use. Please see DataFrames.jl for methods of converting arrays and other data types into the DataFrames type, and CSV.jl for saving data structures as arrays.","category":"page"},{"location":"#Intro-1","page":"Home","title":"Intro","text":"","category":"section"},{"location":"man/solve/#solve.jl-Documentation-1","page":"Solve","title":"solve.jl Documentation","text":"","category":"section"},{"location":"man/solve/#","page":"Solve","title":"Solve","text":"CurrentModule = solve","category":"page"},{"location":"man/solve/#solve.SolverGLPK-1","page":"Solve","title":"solve.SolverGLPK","text":"","category":"section"},{"location":"man/solve/#","page":"Solve","title":"Solve","text":"SolverGLPK(type_arr,type_probs,cap_arr,folder,print_bool,infocon_bool,eff_bool)","category":"page"},{"location":"man/solve/#solve.SolverGLPK-NTuple{7,Any}","page":"Solve","title":"solve.SolverGLPK","text":"SolverGLPK(num_types,num_objects,type_arr,type_probs,cap_arr,folder,print_bool,infocon_bool,eff_bool)\n\nApplies ModelSolver with GLPK Optimizer.\n\n\n\n\n\n","category":"method"},{"location":"man/solve/#","page":"Solve","title":"Solve","text":"Let us consider an example where the input is constructed using gen.ProblemGeneratorSimple. ","category":"page"},{"location":"man/solve/#","page":"Solve","title":"Solve","text":"using DataFrames, Distributions\ninclude(abspath(\"../../../../basic-program-share/src/solver/modules/gen/src/gen.jl\"))\ncap_df = DataFrame(cap =[.3,.7,.5]); util_df = DataFrame(mean =[10,15,20]); shock_df = DataFrame(shock=[.1,.9])\ninput = gen.ProblemGeneratorSimple(util_df,shock_df,cap_df,Logistic(),\"DF\")\ninclude(abspath(\"../../../../basic-program-share/src/solver/modules/solve/src/solve.jl\"))\nusing JuMP, GLPK, MathOptInterface\nconst MOI = MathOptInterface\nimport JuMP: GenericAffExpr\nassignments = solve.SolverGLPK(input[1],input[2],input[3],\"output\",0,1,0)[1]\ncorresponding_types = solve.SolverGLPK(input[1],input[2],input[3],\"output\",0,1,0)[2]\ndistribution_of_corresponding_types = solve.SolverGLPK(input[1],input[2],input[3],\"output\",0,1,0)[3]","category":"page"},{"location":"man/solve/#","page":"Solve","title":"Solve","text":"Next, let consider an example where the input is given directly.","category":"page"},{"location":"man/solve/#","page":"Solve","title":"Solve","text":"using DataFrames, Distributions\ninclude(abspath(\"../../../../basic-program-share/src/solver/modules/solve/src/solve.jl\"))\nusing JuMP, GLPK, MathOptInterface, Random\nconst MOI = MathOptInterface\nimport JuMP: GenericAffExpr\nrng = MersenneTwister(1234);\ntype_arr = randn!(rng,zeros(4,2)); type_arr = broadcast(+,1,type_arr)\ntype_probs = randn!(rng,zeros(4,2)); type_probs = broadcast(+,1,type_probs); type_probs = broadcast(/,type_probs,sum(type_probs))\ncap_arr = Array{Float64}(undef, 2); cap_arr[1] = .5; cap_arr[2] = .8\nassignments = solve.SolverGLPK(type_arr,type_probs,cap_arr,\"output\",0,1,0)[1]\ncorresponding_types = solve.SolverGLPK(type_arr,type_probs,cap_arr,\"output\",0,1,0)[2]\ndistribution_of_corresponding_types = solve.SolverGLPK(type_arr,type_probs,cap_arr,\"output\",0,1,0)[3]","category":"page"},{"location":"man/solve/#solve.ModelSolver-1","page":"Solve","title":"solve.ModelSolver","text":"","category":"section"},{"location":"man/solve/#","page":"Solve","title":"Solve","text":"ModelSolver(type_arr,type_probs,cap_arr,m,folder,print_bool,infocon_bool,eff_bool)","category":"page"},{"location":"man/solve/#solve.ModelSolver-NTuple{8,Any}","page":"Solve","title":"solve.ModelSolver","text":"ModelSolver(num_types,num_objects,type_arr,type_probs,cap_arr,m,folder,print_bool,infocon_bool,eff_bool)\n\nGiven a model m, ModelSolver solves the optimization problem subject to the appropriate constrains.\n\n\n\n\n\n","category":"method"},{"location":"man/solve/#","page":"Solve","title":"Solve","text":"Given the number of types, number of means, capacity array, type arrays and type distribution, finds the optimal allocation given the following constraints:","category":"page"},{"location":"man/solve/#","page":"Solve","title":"Solve","text":"Capacity: Sigma_theta in Theta f_theta m_theta a leq c_a forall a in A\nFeasibility: Sigma_a in A m_theta a leq 1 forall theta in Theta\nNon-negativity: m_theta a geq 0 forall (thetaa) in Theta times A\n(Incentive Compatibility, applied when infocon_bool==1): Sigma_a in A u_theta a m_theta a - Sigma_a in A u_theta a m_theta a geq 0 forall thetatheta in Theta\n(Efficiency, applied when eff_bool==1): pending","category":"page"},{"location":"man/solve/#","page":"Solve","title":"Solve","text":"Saves the following tuple when print_bool ==1: (assignment array,type array,type distribution array, vector of type vectors by shock, incentive constraint designation). Otherwise, returns (assignment array,type array,type distribution array, vector of type vectors by shock). Assignment array takes the form such that element (i,j) gives the probability that type i is assigned to each object j.","category":"page"},{"location":"man/solve/#","page":"Solve","title":"Solve","text":"Is parametrized such that the type distribution represents unit capacity.","category":"page"}]
}
