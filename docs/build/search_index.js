var documenterSearchIndex = {"docs":
[{"location":"man/gen/#gen.jl-Documentation-1","page":"Generating a Problem","title":"gen.jl Documentation","text":"","category":"section"},{"location":"man/gen/#","page":"Generating a Problem","title":"Generating a Problem","text":"CurrentModule = gen","category":"page"},{"location":"man/gen/#gen.ProblemGeneratorSimple-1","page":"Generating a Problem","title":"gen.ProblemGeneratorSimple","text":"","category":"section"},{"location":"man/gen/#","page":"Generating a Problem","title":"Generating a Problem","text":"ProblemGeneratorSimple(util,shock,cap,shock_distribution,mode)","category":"page"},{"location":"man/gen/#gen.ProblemGeneratorSimple-NTuple{5,Any}","page":"Generating a Problem","title":"gen.ProblemGeneratorSimple","text":"ProblemGeneratorSimple(util,shock,cap,shock_distribution,mode)\n\nTakes input parameters for base utilities, quantiles at which preferences are obtained, capacities of objects, and distribution (given as Distributions.jl type).\n\n\n\n\n\n","category":"method"},{"location":"man/gen/#","page":"Generating a Problem","title":"Generating a Problem","text":"Takes DataFrame inputs for utilities, shocks, capacities, and takes distributions for the shocks over each mean. Supports either a single distribution type for all inputs (e.g. Logistic()) or an array of distributions types of size equal to the number of means (e.g. [Logistic(),Logistic(),Logistic()] ). Can be switched into DataFrame mode (mode=\"DF\") and CSV mode (mode=\"CSV\"), depending on input type.","category":"page"},{"location":"man/gen/#","page":"Generating a Problem","title":"Generating a Problem","text":"Returns an array of types (where entry (i,j) represents the value type i assigns to object j), an array of probabilities over these types (the distribution), and the capacity array.","category":"page"},{"location":"man/gen/#","page":"Generating a Problem","title":"Generating a Problem","text":"note: Note\nshock_distribution currently supports only continuous distributions included in Distributions.jl. For example, Logistic() is a valid input, but logistic is not. Please see this link for more details.","category":"page"},{"location":"man/gen/#","page":"Generating a Problem","title":"Generating a Problem","text":"Let us consider an example where the problem specification is given as a set of DataFrames through the command line:","category":"page"},{"location":"man/gen/#","page":"Generating a Problem","title":"Generating a Problem","text":"using DataFrames, Distributions\ninclude(abspath(\"../../../../basic-program-share/src/solver/modules/gen/src/gen.jl\"))\ncap_df = DataFrame(cap =[.7,.3]); util_df = DataFrame(mean =[15,20]); shock_df = DataFrame(shock=[.1,.8])\ngen.ProblemGeneratorSimple(util_df,shock_df,cap_df,Logistic(),\"DF\")[1]\ngen.ProblemGeneratorSimple(util_df,shock_df,cap_df,Logistic(),\"DF\")[2]\ngen.ProblemGeneratorSimple(util_df,shock_df,cap_df,Logistic(),\"DF\")[3]","category":"page"},{"location":"man/gen/#","page":"Generating a Problem","title":"Generating a Problem","text":"Now, let us consider an example where the problem specification is given as a set of paths to the appropriate CSV files:","category":"page"},{"location":"man/gen/#","page":"Generating a Problem","title":"Generating a Problem","text":"using DataFrames, CSV, Distributions\ninclude(abspath(\"../../../../basic-program-share/src/solver/modules/gen/src/gen.jl\"))\ncap_df = DataFrame(cap =[.7,.3]); util_df = DataFrame(mean =[15,20]); shock_df = DataFrame(shock=[.1,.8])\nCSV.write(\"cap.csv\", cap_df, writeheader=true);CSV.write(\"util.csv\", util_df, writeheader=true);CSV.write(\"shock.csv\", shock_df, writeheader=true)\ngen.ProblemGeneratorSimple(\"util.csv\",\"shock.csv\",\"cap.csv\",[Logistic(),Uniform()],\"CSV\")[1]\ngen.ProblemGeneratorSimple(\"util.csv\",\"shock.csv\",\"cap.csv\",[Logistic(),Uniform()],\"CSV\")[2]\ngen.ProblemGeneratorSimple(\"util.csv\",\"shock.csv\",\"cap.csv\",[Logistic(),Uniform()],\"CSV\")[3]\nrm(\"util.csv\");rm(\"shock.csv\");rm(\"cap.csv\")","category":"page"},{"location":"man/gen/#","page":"Generating a Problem","title":"Generating a Problem","text":"We recommend this second method for ease of use. Please see DataFrames.jl for methods of converting arrays and other data types into the DataFrames type, and CSV.jl for saving data structures as arrays.","category":"page"},{"location":"man/plots/#solve.jl-Documentation-1","page":"Plotting","title":"solve.jl Documentation","text":"","category":"section"},{"location":"man/plots/#","page":"Plotting","title":"Plotting","text":"CurrentModule = plots","category":"page"},{"location":"man/timing/#exec*n*time.jl-Documentation-1","page":"Timing Functions","title":"execntime.jl Documentation","text":"","category":"section"},{"location":"man/timing/#","page":"Timing Functions","title":"Timing Functions","text":"CurrentModule = timing","category":"page"},{"location":"#Intro-1","page":"Home","title":"Intro","text":"","category":"section"},{"location":"man/solve/#solve.jl-Documentation-1","page":"Solving a Problem","title":"solve.jl Documentation","text":"","category":"section"},{"location":"man/solve/#","page":"Solving a Problem","title":"Solving a Problem","text":"CurrentModule = solve","category":"page"},{"location":"man/solve/#solve.SolverL-1","page":"Solving a Problem","title":"solve.SolverL","text":"","category":"section"},{"location":"man/solve/#","page":"Solving a Problem","title":"Solving a Problem","text":"SolverL(type_arr,type_probs,cap_arr;infocon_bool=true,eff_bool=false)","category":"page"},{"location":"man/solve/#solve.SolverL-Tuple{Any,Any,Any}","page":"Solving a Problem","title":"solve.SolverL","text":"SolverL(type_arr,type_probs,cap_arr;infocon_bool=true,eff_bool=false)\n\nApplies ModelSolver with GLPK Optimizer. Use for Linear Programming (without prices)\n\n\n\n\n\n","category":"method"},{"location":"man/solve/#","page":"Solving a Problem","title":"Solving a Problem","text":"This solver should be used for linear programming problems, as the GLPK optimizer used only accepts such problems. For non-linear problems (using prices), please see SolverNL.","category":"page"},{"location":"man/solve/#","page":"Solving a Problem","title":"Solving a Problem","text":"Given the type array, type distribution, and capacity array, finds the optimal allocation given the following constraints:","category":"page"},{"location":"man/solve/#","page":"Solving a Problem","title":"Solving a Problem","text":"Capacity: Sigma_theta in Theta f_theta m_theta a leq c_a forall a in A\nFeasibility: Sigma_a in A m_theta a leq 1 forall theta in Theta\nNon-negativity: m_theta a geq 0 forall (thetaa) in Theta times A\n(Incentive Compatibility, applied when infocon_bool==1): Sigma_a in A u_theta a m_theta a - Sigma_a in A u_theta a m_theta a geq 0 forall thetatheta in Theta\n(Efficiency, applied when eff_bool==1): pending","category":"page"},{"location":"man/solve/#","page":"Solving a Problem","title":"Solving a Problem","text":"Saves the following tuple when print_bool ==1 to the folder given by folder ==path/to/folder: (assignment array,type array,type distribution array, incentive constraint designation). Otherwise, returns (assignment array,type array,type distribution array). Assignment array takes the form such that element (i,j) gives the probability that type i is assigned to each object j.","category":"page"},{"location":"man/solve/#","page":"Solving a Problem","title":"Solving a Problem","text":"Is parametrized such that the type distribution represents unit capacity. Because prices enter the price mechanism via an incentive constraint, this solver does not support inputs for which price_type!=\"none\" and info_bool==false.","category":"page"},{"location":"man/solve/#","page":"Solving a Problem","title":"Solving a Problem","text":"Let us consider an example where the input is constructed using gen.ProblemGeneratorSimple. ","category":"page"},{"location":"man/solve/#","page":"Solving a Problem","title":"Solving a Problem","text":"using DataFrames, Distributions\ninclude(abspath(\"../../../../basic-program-share/src/solver/modules/gen/src/gen.jl\"))\ncap_df = DataFrame(cap =[.3,.7,.5]); util_df = DataFrame(mean =[10,15,20]); shock_df = DataFrame(shock=[.1,.9])\ninput = gen.ProblemGeneratorSimple(util_df,shock_df,cap_df,Logistic(),\"DF\")\ninclude(abspath(\"../../../../basic-program-share/src/solver/modules/solve/src/solve.jl\"))\nusing JuMP, GLPK, MathOptInterface\nconst MOI = MathOptInterface\nimport JuMP: GenericAffExpr\na,b,c,d = solve.SolverL(input[1],input[2],input[3])\nwelfare = a\nassignments = b\ncorresponding_types = c\ndistribution_of_corresponding_types = d","category":"page"},{"location":"man/solve/#","page":"Solving a Problem","title":"Solving a Problem","text":"Next, let's consider an example where the input is given directly.","category":"page"},{"location":"man/solve/#","page":"Solving a Problem","title":"Solving a Problem","text":"using DataFrames, Distributions\ninclude(abspath(\"../../../../basic-program-share/src/solver/modules/solve/src/solve.jl\"))\nusing JuMP, GLPK, MathOptInterface, Random\nconst MOI = MathOptInterface\nimport JuMP: GenericAffExpr\nrng = MersenneTwister(1234);\ntype_arr = randn!(rng,zeros(4,2)); type_arr = broadcast(+,1,type_arr)\ntype_probs = randn!(rng,zeros(4,2)); type_probs = broadcast(+,1,type_probs); type_probs = broadcast(/,type_probs,sum(type_probs))\ncap_arr = Array{Float64}(undef, 2); cap_arr[1] = .5; cap_arr[2] = .8\na,b,c,d = solve.SolverL(type_arr,type_probs,cap_arr)\nwelfare = a\nassignments = b\ncorresponding_types = c\ndistribution_of_corresponding_types = d","category":"page"},{"location":"man/solve/#solve.SolverNL-1","page":"Solving a Problem","title":"solve.SolverNL","text":"","category":"section"},{"location":"man/solve/#","page":"Solving a Problem","title":"Solving a Problem","text":"SolverNL(type_arr,type_probs,cap_arr;infocon_bool=true,eff_bool=false,price_type=\"lower\")","category":"page"},{"location":"man/solve/#solve.SolverNL-Tuple{Any,Any,Any}","page":"Solving a Problem","title":"solve.SolverNL","text":"SolverNL(type_arr,type_probs,cap_arr;infocon_bool=true,eff_bool=false,price_type=\"lower\")\n\nApplies ModelSolver with Ipopt Optimizer. Use for Nonlinear Programming (with prices)\n\n\n\n\n\n","category":"method"},{"location":"man/solve/#","page":"Solving a Problem","title":"Solving a Problem","text":"This solver should be used for non-linear programming problems (typically using prices), as the Ipopt optimizer used is not optimized for linear programming and will underperform the optimizer used in SolverL.","category":"page"},{"location":"man/solve/#","page":"Solving a Problem","title":"Solving a Problem","text":"Given the type array, type distribution, and capacity array, finds the optimal allocation given the following constraints:","category":"page"},{"location":"man/solve/#","page":"Solving a Problem","title":"Solving a Problem","text":"Capacity: Sigma_theta in Theta f_theta m_theta a leq c_a forall a in A\nFeasibility: Sigma_a in A m_theta a leq 1 forall theta in Theta\nNon-negativity: m_theta a geq 0 forall (thetaa) in Theta times A\n(Incentive Compatibility, applied when infocon_bool==1): Sigma_a in A u_theta a m_theta a - Sigma_a in A u_theta a m_theta a geq 0 forall thetatheta in Theta\n(Efficiency, applied when eff_bool==1): pending","category":"page"},{"location":"man/solve/#","page":"Solving a Problem","title":"Solving a Problem","text":"Saves the following tuple when print_bool ==1 to the folder given by folder ==path/to/folder: (assignment array,type array,type distribution array, incentive constraint designation). Otherwise, returns (assignment array,type array,type distribution array). Assignment array takes the form such that element (i,j) gives the probability that type i is assigned to each object j.","category":"page"},{"location":"man/solve/#","page":"Solving a Problem","title":"Solving a Problem","text":"Is parametrized such that the type distribution represents unit capacity. Because prices enter the price mechanism via an incentive constraint, this solver does not support inputs for which price_type!=\"none\" and info_bool==false.","category":"page"},{"location":"man/solve/#","page":"Solving a Problem","title":"Solving a Problem","text":"Let us consider an example of a lower-bound price-regime where the input is constructed using gen.ProblemGeneratorSimple. ","category":"page"},{"location":"man/solve/#","page":"Solving a Problem","title":"Solving a Problem","text":"using DataFrames, Distributions\ninclude(abspath(\"../../../../basic-program-share/src/solver/modules/gen/src/gen.jl\"))\ncap_df = DataFrame(cap =[.3,.7]); util_df = DataFrame(mean =[10,15]); shock_df = DataFrame(shock=[.1,.9])\ninput = gen.ProblemGeneratorSimple(util_df,shock_df,cap_df,Logistic(),\"DF\")\ninclude(abspath(\"../../../../basic-program-share/src/solver/modules/solve/src/solve.jl\"))\nusing JuMP, GLPK, MathOptInterface, Ipopt\nconst MOI = MathOptInterface\nimport JuMP: GenericAffExpr\na,b,c,d,f = solve.SolverNL(input[1],input[2],input[3],price_type=\"lower\")\nwelfare = a\nassignments = b\ncorresponding_types = c\ndistribution_of_corresponding_types = d\nprices = f","category":"page"},{"location":"man/solve/#","page":"Solving a Problem","title":"Solving a Problem","text":"Now, let us consider an example of an upper-bound price-regime where the input is constructed using gen.ProblemGeneratorSimple. ","category":"page"},{"location":"man/solve/#","page":"Solving a Problem","title":"Solving a Problem","text":"using DataFrames, Distributions\ninclude(abspath(\"../../../../basic-program-share/src/solver/modules/gen/src/gen.jl\"))\ncap_df = DataFrame(cap =[.3,.7]); util_df = DataFrame(mean =[10,15]); shock_df = DataFrame(shock=[.1,.9])\ninput = gen.ProblemGeneratorSimple(util_df,shock_df,cap_df,Logistic(),\"DF\")\ninclude(abspath(\"../../../../basic-program-share/src/solver/modules/solve/src/solve.jl\"))\nusing JuMP, GLPK, MathOptInterface, Ipopt\nconst MOI = MathOptInterface\nimport JuMP: GenericAffExpr\na,b,c,d,f = solve.SolverNL(input[1],input[2],input[3],price_type=\"upper\")\nwelfare = a\nassignments = b\ncorresponding_types = c\ndistribution_of_corresponding_types = d\nprices = f","category":"page"},{"location":"man/solve/#","page":"Solving a Problem","title":"Solving a Problem","text":"Finally, let us consider an example of a raffle regime where the input is constructed using gen.ProblemGeneratorSimple. ","category":"page"},{"location":"man/solve/#","page":"Solving a Problem","title":"Solving a Problem","text":"using DataFrames, Distributions\ninclude(abspath(\"../../../../basic-program-share/src/solver/modules/gen/src/gen.jl\"))\ncap_df = DataFrame(cap =[.3,.7]); util_df = DataFrame(mean =[10,15]); shock_df = DataFrame(shock=[.1,.9])\ninput = gen.ProblemGeneratorSimple(util_df,shock_df,cap_df,Logistic(),\"DF\")\ninclude(abspath(\"../../../../basic-program-share/src/solver/modules/solve/src/solve.jl\"))\nusing JuMP, GLPK, MathOptInterface, Ipopt\nconst MOI = MathOptInterface\nimport JuMP: GenericAffExpr\na,b,c,d,f = solve.SolverNL(input[1],input[2],input[3],price_type=\"raffle\")\nwelfare = a\nassignments = b\ncorresponding_types = c\ndistribution_of_corresponding_types = d\nprices = f","category":"page"},{"location":"man/solve/#","page":"Solving a Problem","title":"Solving a Problem","text":"As we can see, here the bounds are rather tight, and the proposition that the raffle regime will obtain a welfare lower than that of the optimal price regime is corroborated.","category":"page"}]
}
