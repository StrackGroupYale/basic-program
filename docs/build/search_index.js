var documenterSearchIndex = {"docs":
[{"location":"man/gen/#gen.jl-Documentation-1","page":"Gen","title":"gen.jl Documentation","text":"","category":"section"},{"location":"man/gen/#","page":"Gen","title":"Gen","text":"CurrentModule = gen","category":"page"},{"location":"man/gen/#gen.QuantileVal-1","page":"Gen","title":"gen.QuantileVal","text":"","category":"section"},{"location":"man/gen/#","page":"Gen","title":"Gen","text":"QuantileVal(distribution, quant)","category":"page"},{"location":"man/gen/#gen.QuantileVal-Tuple{Any,Any}","page":"Gen","title":"gen.QuantileVal","text":"QuantileVal(distribution, quant)\n\nTEXT\n\n\n\n\n\n","category":"method"},{"location":"man/gen/#","page":"Gen","title":"Gen","text":"Takes distribution type and the quantile (i.e. 50 for 50th quantile) and returns pdf evaluated at that quantile. Is used to calculate joint probalities (we assume independence of types). Example:","category":"page"},{"location":"man/gen/#","page":"Gen","title":"Gen","text":"using Distributions\ninclude(\"/Users/AnR/Dropbox/Basic-Profile/basic-program-share/src/solver/modules/gen/src/gen.jl\")\ndistribution=\"logistic\"; quant = 40\ngen.QuantileVal(distribution,quant)","category":"page"},{"location":"man/gen/#gen.ProblemGenerator-1","page":"Gen","title":"gen.ProblemGenerator","text":"","category":"section"},{"location":"man/gen/#","page":"Gen","title":"Gen","text":"ProblemGenerator(util,shock,cap,shock_distribution,mode)","category":"page"},{"location":"man/gen/#gen.ProblemGenerator-NTuple{5,Any}","page":"Gen","title":"gen.ProblemGenerator","text":"ProblemGenerator(util,shock,cap,shock_distribution,mode)\n\nTEXT\n\n\n\n\n\n","category":"method"},{"location":"man/gen/#","page":"Gen","title":"Gen","text":"Takes DataFrame inputs for utilities, shocks, capacities, and a shock distribution. Can be switched into DataFrame mode (mode=\"DF\") and CSV mode (mode=\"CSV\"), depending on input type.","category":"page"},{"location":"man/gen/#","page":"Gen","title":"Gen","text":"Generates the number of types, means, the vector of capacities, the vector giving the distribution of types, and the set of types in three forms:","category":"page"},{"location":"man/gen/#","page":"Gen","title":"Gen","text":"an array of types by quantile (each row is a type)\nan unnormalized array of \"raw\" types (mean + shock) (each row is a type)\nand a vector of types in vector form. ","category":"page"},{"location":"man/gen/#","page":"Gen","title":"Gen","text":"shock_distribution currently supports only \"logistic\" and \"uniform\".","category":"page"},{"location":"man/gen/#","page":"Gen","title":"Gen","text":"Example:","category":"page"},{"location":"man/gen/#","page":"Gen","title":"Gen","text":"using DataFrames\ninclude(\"/Users/AnR/Dropbox/Basic-Profile/basic-program-share/src/solver/modules/gen/src/gen.jl\")\ncap_df = DataFrame(cap =[.7,.3]); util_df = DataFrame(mean =[15,20]); shock_df = DataFrame(shock=[.1,.5])\ngen.ProblemGenerator(util_df,shock_df,cap_df,\"logistic\",\"DF\")[1:2]\ngen.ProblemGenerator(util_df,shock_df,cap_df,\"logistic\",\"DF\")[3]\ngen.ProblemGenerator(util_df,shock_df,cap_df,\"logistic\",\"DF\")[4]\ngen.ProblemGenerator(util_df,shock_df,cap_df,\"logistic\",\"DF\")[5]\ngen.ProblemGenerator(util_df,shock_df,cap_df,\"logistic\",\"DF\")[6]\ngen.ProblemGenerator(util_df,shock_df,cap_df,\"logistic\",\"DF\")[7]","category":"page"},{"location":"#Intro-1","page":"Home","title":"Intro","text":"","category":"section"},{"location":"man/solve/#solve.jl-Documentation-1","page":"Solve","title":"solve.jl Documentation","text":"","category":"section"},{"location":"man/solve/#","page":"Solve","title":"Solve","text":"CurrentModule = solve","category":"page"},{"location":"man/solve/#solve.SolverGLPK-1","page":"Solve","title":"solve.SolverGLPK","text":"","category":"section"},{"location":"man/solve/#","page":"Solve","title":"Solve","text":"SolverGLPK(num_types,num_objects,type_arr,type_probs,cap_arr,rtype_arr,folder,type_vec_shock,print_bool,infocon_bool,eff_bool)","category":"page"},{"location":"man/solve/#solve.SolverGLPK-NTuple{11,Any}","page":"Solve","title":"solve.SolverGLPK","text":"SolverGLPK(num_types,num_objects,type_arr,type_probs,cap_vec,rtype_arr,folder,type_vec_shock,print_bool,infocon_bool,eff_bool)\n\nApplies ModelSolver with GLPK Optimizer\n\n\n\n\n\n","category":"method"},{"location":"man/solve/#","page":"Solve","title":"Solve","text":"using DataFrames\ninclude(\"/Users/AnR/Dropbox/Basic-Profile/basic-program-share/src/solver/modules/gen/src/gen.jl\")\ncap_df = DataFrame(cap =[.3,.7,.5]); util_df = DataFrame(mean =[10,15,20]); shock_df = DataFrame(shock=[.1,.9])\ninput = gen.ProblemGenerator(util_df,shock_df,cap_df,\"logistic\",\"DF\")\ninclude(\"/Users/AnR/Dropbox/Basic-Profile/basic-program-share/src/solver/modules/solve/src/solve.jl\")\nusing JuMP, GLPK, MathOptInterface\nconst MOI = MathOptInterface\nimport JuMP: GenericAffExpr\noutput = solve.SolverGLPK(input[1],input[2],input[4],input[7],input[3],input[6],\"output\",input[5],0,1,0)[1]","category":"page"},{"location":"man/solve/#solve.ModelSolver-1","page":"Solve","title":"solve.ModelSolver","text":"","category":"section"},{"location":"man/solve/#","page":"Solve","title":"Solve","text":"ModelSolver(num_types,num_objects,type_arr,type_probs,cap_arr,rtype_arr,m,folder,type_vec_shock,print_bool,infocon_bool,eff_bool)","category":"page"},{"location":"man/solve/#solve.ModelSolver-NTuple{12,Any}","page":"Solve","title":"solve.ModelSolver","text":"ModelSolver(num_types,num_objects,type_arr,type_probs,cap_arr,rtype_arr,m,folder,type_vec_shock,print_bool,infocon_bool,eff_bool)\n\nGiven a model m, ModelSolver solves the optimization problem subject to the appropriate constrains.\n\n\n\n\n\n","category":"method"},{"location":"man/solve/#","page":"Solve","title":"Solve","text":"Given the number of types, number of means, capacity array, type arrays and type distribution, finds the optimal allocation given the following constraints:","category":"page"},{"location":"man/solve/#","page":"Solve","title":"Solve","text":"Capacity\nFeasibility\nNon-negativity\n(Incentive Compatibility, applied when infocon_bool==1)\n(Efficiency, applied when eff_bool==1)","category":"page"},{"location":"man/solve/#","page":"Solve","title":"Solve","text":"Saves the following tuple when print_bool ==1: (assignment array,type array,type distribution array, vector of raw type vectors, incentive constraint designation). Otherwise, returns (assignment array,type array,type distribution array, vector of raw type vectors). Assignment array takes the form such that element (i,j) gives the probability that type i is assigned to each object j.","category":"page"},{"location":"man/solve/#","page":"Solve","title":"Solve","text":"Is parametrized such that the type distribution represents unit capacity.","category":"page"}]
}
